import numpy as np
from avstack.geometry import (
    Attitude,
    Box3D,
    GlobalOrigin3D,
    Position,
    transform_orientation,
)
from PIL import ImageDraw


def add_metadata_to_image(
    image, x0, y1, class_, score, show_class=False, show_score=False
):
    draw = ImageDraw.Draw(image)
    if show_class and show_score:
        draw.text((x0, y1 + 2), "{}:{}".format(class_, score), fill=(0, 255, 0))
    elif show_class:
        draw.text((x0, y1 + 2), "{}".format(class_), fill=(0, 255, 0))
    elif show_score:
        draw.text((x0, y1 + 2), "{}".format(score), fill=(0, 255, 0))
    return image


def draw_box_detections_3d(
    image,
    detections,
    extent=[(-100, 100), (-100, 100)],
    img_size=(600, 600),
    show_class=False,
    show_score=False,
):
    # get pixel scaling
    pix_per_m = (
        img_size[0] / (extent[0][1] - extent[0][0]),
        img_size[1] / (extent[1][1] - extent[1][0]),
    )

    draw = ImageDraw.Draw(image)
    for detection in detections:
        bev_corners = detection.box.corners[:4, :2]
        vertices = bev_corners * pix_per_m
        vertices[:, 0] += img_size[0] / 2
        vertices[:, 1] += img_size[1] / 2
        vertices = [(x, y) for x, y in vertices]
        draw.polygon(vertices, outline=(0, 255, 0), width=4)

        class_ = detection.obj_type
        score = detection.score if detection.score else "N/A"
        image = add_metadata_to_image(
            image, vertices[0][0], vertices[0][1], class_, score, show_class, show_score
        )

    del draw
    return image


def draw_stonesoup_box_tracks_3d(
    image,
    tracks,
    extent=[(-100, 100), (-100, 100)],
    img_size=(600, 600),
    show_history=True,
    show_class=True,
    show_score=True,
):
    """Draw tracks on an image

    Parameters
    ----------
    image: :class:`PIL.Image`
        Image on which to draw the tracks
    detections: : set of :class:`~.Tracks`
        A set of tracks generated by our :class:`~.MultiTargetTracker`
    show_history: bool
        Whether to draw the trajectory of the track. Default is ``True``
    show_class: bool
        Whether to draw the class of the object. Default is ``True``
    show_score: bool
        Whether to draw the score of the object. Default is ``True``

    Returns
    -------
    : :class:`PIL.Image`
        Image with tracks drawn

    """
    # get pixel scaling
    pix_per_m = (
        img_size[0] / (extent[0][1] - extent[0][0]),
        img_size[1] / (extent[1][1] - extent[1][0]),
    )

    # np.array(track.states[0].state_vector[[0, 2, 4]])

    draw = ImageDraw.Draw(image)
    for track in tracks:
        # import pdb; pdb.set_trace()
        bboxes = [
            Box3D(
                position=Position(
                    np.array(state.state_vector[[0, 2, 4]]).reshape(3),
                    GlobalOrigin3D,
                ),
                attitude=Attitude(
                    transform_orientation(
                        [0, 0, state.state_vector[9]], "euler", "quat"
                    ),
                    GlobalOrigin3D,
                ),
                hwl=np.array(state.state_vector[[6, 7, 8]]).reshape(3),
            )
            for state in track.states
        ]

        # draw current box
        bev_corners = bboxes[-1].corners[:4, :2]
        vertices = bev_corners * pix_per_m
        vertices[:, 0] += img_size[0] / 2
        vertices[:, 1] += img_size[1] / 2
        vertices = [(x, y) for x, y in vertices]
        draw.polygon(vertices, outline=(255, 0, 0), width=2)

        if show_history:
            pts = [
                (
                    img_size[0] / 2 + box.t[0] * pix_per_m[0],
                    img_size[1] / 2 + box.t[1] * pix_per_m[1],
                )
                for box in bboxes
            ]
            draw.line(pts, fill=(255, 0, 0), width=2)

        class_ = track.metadata["class"]["name"]
        score = round(
            float(track.metadata["score"]) if track.metadata["score"] else 0.0, 2
        )
        image = add_metadata_to_image(
            image, vertices[0][0], vertices[0][1], class_, score, show_class, show_score
        )
    return image


def draw_box_detections_2d(image, detections, show_class=False, show_score=False):
    """Draw detections on an image

    Parameters
    ----------
    image: :class:`PIL.Image`
        Image on which to draw the detections
    detections: : set of AVstack type
        A set of detections from AVstack
    show_class: bool
        Whether to draw the class of the object. Default is ``False``
    show_score: bool
        Whether to draw the score of the object. Default is ``False``

    Returns
    -------
    : :class:`PIL.Image`
        Image with detections drawn
    """
    draw = ImageDraw.Draw(image)
    for detection in detections:
        x0, y0, x1, y1 = detection.box.box2d
        # x0, y0, w, h = np.array(detection.state_vector).reshape(4)
        # x1, y1 = (x0 + w, y0 + h)
        # draw.rectangle([x0, y0, x1, y1], outline=(0, 255, 0), width=1)
        vertices = [
            (x0, y0),
            (x0, y1),
            (x1, y1),
            (x1, y0),
        ]
        draw.polygon(vertices, outline=(0, 255, 0), width=1)

        class_ = detection.obj_type
        score = detection.score if detection.score else "N/A"
        image = add_metadata_to_image(
            image, x0, y1, class_, score, show_class, show_score
        )

    del draw
    return image


def draw_stonesoup_box_tracks_2d(
    image, tracks, show_history=True, show_class=True, show_score=True
):
    """Draw tracks on an image

    Parameters
    ----------
    image: :class:`PIL.Image`
        Image on which to draw the tracks
    detections: : set of :class:`~.Tracks`
        A set of tracks generated by our :class:`~.MultiTargetTracker`
    show_history: bool
        Whether to draw the trajectory of the track. Default is ``True``
    show_class: bool
        Whether to draw the class of the object. Default is ``True``
    show_score: bool
        Whether to draw the score of the object. Default is ``True``

    Returns
    -------
    : :class:`PIL.Image`
        Image with tracks drawn

    """
    draw = ImageDraw.Draw(image)
    for track in tracks:
        bboxes = np.array(
            [
                np.array(state.state_vector[[0, 2, 4, 5]]).reshape(4)
                for state in track.states
            ]
        )
        x0, y0, w, h = bboxes[-1]
        x1 = x0 + w
        y1 = y0 + h
        vertices = [
            (x0, y0),
            (x0, y1),
            (x1, y1),
            (x1, y0),
        ]
        draw.polygon(vertices, outline=(255, 0, 0), width=2)

        if show_history:
            pts = [(box[0] + box[2] / 2, box[1] + box[3] / 2) for box in bboxes]
            draw.line(pts, fill=(255, 0, 0), width=2)

        class_ = track.metadata["class"]["name"]
        score = round(
            float(track.metadata["score"]) if track.metadata["score"] else 0.0, 2
        )
        image = add_metadata_to_image(
            image, x0, y1, class_, score, show_class, show_score
        )
    return image
